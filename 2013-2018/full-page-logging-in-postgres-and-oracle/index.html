<html><head>
<link rel=canonical href=https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle />
<meta name=description content='A blog post from 2018 about Full page logging in Postgres and Oracle'>
<title>Full page logging in Postgres and Oracle</title>
<link rel=stylesheet href=../../style.css media=all>   

</head><body>


<p class=aboutme>
<br/>
<table width=100%>
<tr>
<td>
<div class=message>Follow:
<a href=https://linkedin.com/in/franckpachot>Linkedin</a>, <a href=https://twitter.com/franckpachot>Twitter</a>, <a href=https://www.youtube.com/@franckpachot/community>Youtube</a>, <a href=https://mastodon.social/@FranckPachot>Mastodon</a>, <a href=https://dev.to/franckpachot>dev.to</a>
 </div>
</td><td>
<img src=https://pbs.twimg.com/profile_images/1487359683119788033/4ejaJ4S5_400x400.jpg height=100 width=100/>
</td>
</tr>
</table>
<br/>
</p>


<p class=firstpub>This was first published on <a href=https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle>https://blog.dbi-services.com/full-page-logging-in-postgres-and-oracle</a> (2018-02-14)<br>Republishing for new followers. The content is related to the the versions available at the publication date</p>
								<h1 class="entry-title">Full page logging in Postgres and Oracle</h1>
		<div class="content-inner">
			
						
						
		   
			<p>In my opinion, the volume of logging (aka redo log, aka xlog, aka WAL) is the most important factor for OLTP performance, availability and scalability, for several reasons:</p>
<ul>
<li>This is the only structure where disk latency is a mandatory component of response time</li>
<li>This is a big part of the total volume of backups</li>
<li>This is sequential by nature, and very difficult to scale by parallelizing</li>
</ul>
<p>In this post, I look at the volume of logging generated by some DML in Postgres and Oracle. I know Oracle quite well and just start to look at Postgres. The comparison here is not a contest but a way to better understand. For example, the default behavior of Postgres, with full_page_writes=on, is very similar to Oracle &#8216;begin backup&#8217; mode. The comparison makes no sense for most of Postgres DBAs, but probably helps Oracle DBAs to understand it.</p>
<p><span id="more-21083"></span></p>
<h3>Measure WAL segment writes</h3>
<p>Here is how I measured the volume of transaction log written: start the Postgres server with &#8216;strace -f&#8217; and parse with &#8216;awk&#8217; the open(), write() and close() calls:
<pre>
sudo su postgres &lt;&lt;'END'
export PGDATA=/u01/pgdata
/usr/pgsql-10/bin/pg_ctl stop
strace -e trace=open,close,write,recvfrom -f /usr/pgsql-10/bin/pg_ctl start 2&gt;&amp;1 | awk '
/^[^[]/{
 $0="[pid MAIN] "$0
}
/strace: Process [0-9][0-9]* attached/{
  sub(/^.*strace: /,"strace: ") ; "ps -o cmd -hp " $3 |&amp; getline proc[$3"]"] ; print "" ; print $0,proc[$3"]"]
}
/open[(].*pg_wal[/].* = [0-9]*$/{
 z=$0 ; gsub(qq," ") ; fd_wal[$2 $NF]=$4
}
/checkpoint;/{
total_written_wal=0
}
/write[(]/{
 #pid=$2 ; sub("]","",$2) ; "ps -o cmd -hp " p |&amp; getline proc[p"]"]
 z=$0 ; gsub("[(,]"," ") ; if ( fd_wal[$2 $4]&gt;0 ) { written_wal[$2 $4]=written_wal[$2 $4]+$NF ; total_written_wal=total_written_wal+$NF } next
}
/close[(]/{
 pid=$2 ; sub("[^0-9]","",pid) ;
 z=$0 ; gsub("[()]"," ") ; if ( ( fd_wal[$2 $4]!="" ) &amp;&amp; ( written_wal[$2 $4] &gt; 0 ) ) {
  printf " ( written %d bytes to %s -&gt; total WAL segments: %.2f MB ) cmd=%s\n",written_wal[$2 $4],fd_wal[$2 $4],total_written_wal/1024/1024 , proc[$2] ; fd_wal[$2 $4]=""
 } next
}
' qq='"'
END
</pre></p>
<p>Do not do that in production. This is experimentation in a lab. Do not attach strace to a critical process in production.</p>
<p>There&#8217;s probably an easier way to get the same information, maybe with postgres activity statistics, or through a size counting archive_command, so please don&#8217;t hesitate to comment. Anyway, from the &#8216;write()&#8217; calls I am sure that I&#8217;m counting exactly what I want: the volume of logging written to disk. As an Oracle DBA used to LogWriter and its slave threads managing all writes, I started to trace only the WAL writer process but quickly realized that part ot the logging is directly written by my server process.</p>
<h3>Postgres: insert</h3>
<p>I create a table with some numbers and a 100 bytes character string.
<pre>
create table demo as select generate_series a,generate_series b,generate_series c,generate_series d,generate_series e,generate_series f,lpad('x',100,'x') g from generate_series(0,0);
</pre></p>
<p>The first operation I test is the insert of 1 million rows.
<pre>
insert into demo     select generate_series a,generate_series b,generate_series c,generate_series d,generate_series e,generate_series f,lpad('x',100,'x') g from generate_series(1,1000000);
 ( written 4349952 bytes to pg_wal/000000010000000A0000005F -&gt; total WAL segments: 4.16 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 8192 bytes to pg_wal/000000010000000A0000005F -&gt; total WAL segments: 9.00 MB ) cmd=postgres: wal writer process
 ( written 17735680 bytes to pg_wal/000000010000000A00000060 -&gt; total WAL segments: 20.07 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 3309568 bytes to pg_wal/000000010000000A00000060 -&gt; total WAL segments: 31.40 MB ) cmd=postgres: wal writer process
 ( written 33783808 bytes to pg_wal/000000010000000A00000061 -&gt; total WAL segments: 36.03 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 3997696 bytes to pg_wal/000000010000000A00000061 -&gt; total WAL segments: 39.80 MB ) cmd=postgres: wal writer process
 ( written 49676288 bytes to pg_wal/000000010000000A00000062 -&gt; total WAL segments: 51.19 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 65273856 bytes to pg_wal/000000010000000A00000063 -&gt; total WAL segments: 66.06 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 79364096 bytes to pg_wal/000000010000000A00000064 -&gt; total WAL segments: 82.04 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 6660096 bytes to pg_wal/000000010000000A00000064 -&gt; total WAL segments: 82.39 MB ) cmd=postgres: wal writer process
 ( written 88285184 bytes to pg_wal/000000010000000A00000065 -&gt; total WAL segments: 98.02 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 14491648 bytes to pg_wal/000000010000000A00000065 -&gt; total WAL segments: 106.82 MB ) cmd=postgres: wal writer process
 ( written 101703680 bytes to pg_wal/000000010000000A00000066 -&gt; total WAL segments: 113.99 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 17825792 bytes to pg_wal/000000010000000A00000066 -&gt; total WAL segments: 117.19 MB ) cmd=postgres: wal writer process
 ( written 115769344 bytes to pg_wal/000000010000000A00000067 -&gt; total WAL segments: 128.20 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 18661376 bytes to pg_wal/000000010000000A00000067 -&gt; total WAL segments: 135.09 MB ) cmd=postgres: wal writer process
 ( written 19824640 bytes to pg_wal/000000010000000A00000068 -&gt; total WAL segments: 144.17 MB ) cmd=postgres: wal writer process
 ( written 131350528 bytes to pg_wal/000000010000000A00000068 -&gt; total WAL segments: 148.16 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 27435008 bytes to pg_wal/000000010000000A00000069 -&gt; total WAL segments: 159.80 MB ) cmd=postgres: wal writer process
 ( written 140132352 bytes to pg_wal/000000010000000A00000069 -&gt; total WAL segments: 159.80 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
INSERT 0 1000000
</pre></p>
<p>You can see that my &#8216;strace|awk&#8217; script is running in the background and has counted about 160 MB of logging, partially from the &#8216;postgres: wal writer process&#8217; and partly from &#8216;postgres: demo demo 192.168.56.122(38013)&#8217; serving my connection.</p>
<p>The relation size as stored on disk is about 150 MB;
<pre>
analyze demo;
ANALYZE
select relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, relpages*8/1024 MB from pg_class where relname = 'demo';
 relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | relallvisible | mb
---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+---------------+-----
 demo    |         2200 |   25157 |         0 |    16385 |     0 |       25155 |             0 |    19231 |     1e+06 |             0 | 150
(1 row)
</pre></p>
<p>This makes sense. An insert has to write all new data into the log in order to be able to recover the pages until they are checkpointed.</p>
<p>Note that I have no index on this table for this test.</p>
<h3>Postgres: update</h3>
<p>I&#8217;m now updating one column for all rows.
<pre>
update demo set b=b+1;
 ( written 150528000 bytes to pg_wal/000000010000000A0000006A -&gt; total WAL segments: 4.01 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 162693120 bytes to pg_wal/000000010000000A0000006B -&gt; total WAL segments: 17.84 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 29769728 bytes to pg_wal/000000010000000A0000006B -&gt; total WAL segments: 28.44 MB ) cmd=postgres: wal writer process
...
 ( written 84287488 bytes to pg_wal/000000010000000A00000081 -&gt; total WAL segments: 343.65 MB ) cmd=postgres: wal writer process
 ( written 453705728 bytes to pg_wal/000000010000000A00000082 -&gt; total WAL segments: 347.36 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
UPDATE 1000001
</pre></p>
<p>I touched only a small part of the volume in bytes, but I touched all rows and all pages. An, even if only a few bytes are modified, Postgres logs the whole page to protect from fractured blocks in case of crash (pages partially written). So that&#8217;s about 150 MB. But postgres do not update rows in-place. The whole row is inserted in its new version, which means the whole volume again, which is another 150 MB. If we look at the size of the table, we can see 300MB of pages:
<pre>
analyze demo;
ANALYZE
select relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, relpages*8/1024 MB from pg_class where relname = 'demo';
 relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages |  reltuples  | relallvisible | mb
---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-------------+---------------+-----
 demo    |         2200 |   25157 |         0 |    16385 |     0 |       25155 |             0 |    38462 | 1.21882e+06 |             0 | 300
(1 row)
</pre></p>
<p>So this update has generated even more logging: 347 MB.</p>
<h3>Postgres: sparse update</h3>
<p>Now updating only 1 row out of ten, still one column only:
<pre>
update demo set b=b+1 where mod(a,10)=1;
 ( written 89923584 bytes to pg_wal/000000010000000A00000083 -&gt; total WAL segments: 13.88 MB ) cmd=postgres: wal writer process
 ( written 469123072 bytes to pg_wal/000000010000000A00000084 -&gt; total WAL segments: 22.98 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
...
 ( written 563576832 bytes to pg_wal/000000010000000A0000008D -&gt; total WAL segments: 151.07 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 130940928 bytes to pg_wal/000000010000000A0000008D -&gt; total WAL segments: 151.27 MB ) cmd=postgres: wal writer process
UPDATE 100000
analyze demo;
</pre></p>
<p>So, 10% of the rows had to be copied to their new version, which brings the table size to additional 15 MB.
<pre>
analyze demo;
ANALYZE
select relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, relpages*8/1024 MB from pg_class where relname = 'demo';
 relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages |  reltuples  | relallvisible | mb
---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-------------+---------------+-----
 demo    |         2200 |   25157 |         0 |    16385 |     0 |       25155 |             0 |    40385 | 1.07267e+06 |             0 | 315
(1 row)
</pre></p>
<p>For these additional 15 MB, half of the table pages had to be modified (the current version having to point to the new version), and the logging generated was 150 MB. Because of MVCC at tuple level, doing something similar to &#8216;chained rows&#8217; and &#8216;row migration&#8217; for all updates, and because of full page logging, even sparse updates generate a lot log writes.</p>
<h3>Postgres: delete</h3>
<p>Here is a delete of those million rows:
<pre>
delete from demo;
 ( written 576364544 bytes to pg_wal/000000010000000A0000008E -&gt; total WAL segments: 6.44 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
 ( written 134930432 bytes to pg_wal/000000010000000A0000008E -&gt; total WAL segments: 6.73 MB ) cmd=postgres: wal writer process
 ( written 589225984 bytes to pg_wal/000000010000000A0000008F -&gt; total WAL segments: 18.70 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
...
 ( written 162054144 bytes to pg_wal/000000010000000A00000099 -&gt; total WAL segments: 184.70 MB ) cmd=postgres: wal writer process
 ( written 740352000 bytes to pg_wal/000000010000000A0000009A -&gt; total WAL segments: 189.80 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
DELETE 1000001
 ( written 163217408 bytes to pg_wal/000000010000000A0000009A -&gt; total WAL segments: 196.22 MB ) cmd=postgres: wal writer process
</pre></p>
<p>Marking tuples as deleted does not increase the table:
<pre>
analyze demo;
ANALYZE
select relname, relnamespace, reltype, reloftype, relowner, relam, relfilenode, reltablespace, relpages, reltuples, relallvisible, relpages*8/1024 MB from pg_class where relname = 'demo';
 relname | relnamespace | reltype | reloftype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | relallvisible | mb
---------+--------------+---------+-----------+----------+-------+-------------+---------------+----------+-----------+---------------+-----
 demo    |         2200 |   25157 |         0 |    16385 |     0 |       25155 |             0 |    40385 |    275837 |             0 | 315
(1 row)
</pre></p>
<p>But all current tuples have to be marked as deleted and not visible once the transaction is committed. This touches all pages for the current version, which is more than 150 MB of logging here.</p>
<h3>Postgres: vacuum</h3>
<p>After two updates and a delete, I have old tuples in this table. It seems that VACUUM does not generate any logging:
<pre>
vacuum demo;
 ( written 762445824 bytes to pg_wal/000000010000000A0000009B -&gt; total WAL segments: 14.67 MB ) cmd=postgres: demo demo 192.168.56.122(38013)
VACUUM
</pre>
My guess (but remember that I am a newbie in Postgres) is that in case of a crash occurring before the next checkpoint we will just have to vacuum again. But this is not what was answered in the <a href="https://www.postgresql.org/message-id/4873334A.30207%40postnewspapers.com.au" target="_blank">postgres-general</a> list a few years ago.</p>
<p>Note that full page logging is not necessary for all changes, but only for the first change after the page was read from disk after a checkpoint. This is sufficient to cover future writes failures because recovery will start from there. Once we have full page logged, change vector is sufficient for further recovery. However, I had the same amount of WAL, 15 MB, when vacuuming after a checkpoint.</p>
<h3>Oracle: insert</h3>
<p>Let&#8217;s do some similar things in Oracle, which MVCC implementation is completely different: at block level, with undo logging.
<pre>
SQL&gt; create table demo as select rownum a,rownum b,rownum c,rownum d,rownum e,rownum f,lpad('x',100,'x') g from xmltable('0 to 0');
Table created.
</pre></p>
<p>I have exposed in a <a href="../vmystat-delta-values/index.html" target="_blank">previous post</a> how I get the delta values from V$MYSTAT join V$STATNAME using (STATISTIC#) for &#8216;redo size&#8217;, so no need to strace here. But we can see the same result by measuring the writes to redo log groups (do not double count the multiplexed members).
<pre>
SQL&gt; insert into demo     select rownum a,rownum b,rownum c,rownum d,rownum e,rownum f,lpad('x',100,'x') g from xmltable('1 to 1000000');
1000001 rows inserted.

SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
         141,342      155,218,876               4,380,448          104,411
</pre></p>
<p>This is about 150MB, which is the volume of the table:
<pre>
SQL&gt; exec dbms_stats.gather_table_stats(user,'DEMO');
PL/SQL procedure successfully completed.
SQL&gt; select table_name,num_rows,blocks,(blocks*block_size/1024/1024) MB, avg_row_len from user_tables join dba_tablespaces using(tablespace_name) where table_name='DEMO';

TABLE_NAME                       NUM_ROWS     BLOCKS         MB AVG_ROW_LEN
------------------------------ ---------- ---------- ---------- -----------
DEMO                              1000001      19280    150.625         131
</pre></p>
<p>Conclusion for inserts: all databases have to log the whole data inserted in order to be protected from instance crash. Note that Oracle has a way to insert directly into the file, bypassing the buffer cache, and then reduce the logging required for crash recovery. But I&#8217;m not doing bulk inserts here.</p>
<h3>Oracle: update</h3>
<p>The update in Oracle is done in-place. There is no need to copy the whole row (except in the rare cases where the row increases and do not fit into the block). However, the old value of the column must be copied for MVCC, into the UNDO segment. This is why we see 46 MB of &#8216;undo change vector size&#8217; here.
<pre>
SQL&gt; update demo set b=b+1;
1000001 rows updated.
SQL&gt; commit;
Commit complete.
SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
         170,777      105,301,308              48,641,772           82,221
</pre>
The UNDO is only the change vector, not the full block. If you read about copies of full blocks to rollback segments, it is a confusion either from veterans of Oracle 5, or a misunderstanding of flashback features. The UNDO being stored in segments, written first into buffer cache, it is protected by redo logging, so about 46 MB of redo is actually the redo vector of undo vectors. The other 54 MB of redo is the new value of the update.</p>
<h3>Oracle: sparse update</h3>
<p>The logging of change vectors rather than full pages is even cheaper with sparse updates:
<pre>
SQL&gt; update demo set b=b+1 where mod(a,10)=1;
100001 rows updated.
SQL&gt; commit;
Commit complete.
SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
          56,583       15,414,328               6,111,608           36,921
</pre>
The volume of undo and redo generated is only 15 MB here, including 6 MB of undo vectors. This is really optimized and this is one reason why you should update only the columns changed (and not use the default non-dynamic update of Hibernate for example).</p>
<h3>Oracle: delete</h3>
<p>The delete has to mark all rows as deleted and because the space can immediately be reused then whole row must be logged into the UNDO, and this has to be logged into the REDO, so the delete generates lot of logging:
<pre>
SQL&gt; delete from demo;
1000001 rows deleted.
SQL&gt; commit;
Commit complete.
SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
       2,124,823      403,755,892             240,302,088        1,093,821
</pre></p>
<p>I have no indexes here. With indexes, all index entries have to be marked as deleted, and this generates undo and redo vector because MVCC in Oracle is at block level: each block modification &#8211; for table or index &#8211; have to be logged.</p>
<p>Deleting a lot of rows is an expensive operation in Oracle. For bulk purges, it is often better to truncate and insert /*+ append */ when possible (as in non-atomic materialized view refresh). Partitioning helps for that for example to purge old data when partitioned on date.</p>
<h3>Postgres without full page logging</h3>
<p>Given the huge overhead, is full page logging really required? There are plans to avoid it, mentioned in the <a href="https://wiki.postgresql.org/wiki/Todo#Write-Ahead_Log" target="_blank">Postgres ToDo wiki</a>, or at least to keep it only short term for crash recovery and not media recovery. Another possibility is to implement a checksum on the blocks so that fractured blocks can be detected. Then, when detected, the fractured blocks may not need full page logging to recover them if we can restore a previous backup. This takes longer to recover, but can be acceptable given the low probability of this kind of failure. In addition to that, when you have a physical standby synchronized with log-shipping, you have a easy way to recover without having to restore files. But you need a checksum to detect the problem.</p>
<p>Without a checksum, the problem is the detection of partial writes. But if you trust your storage and if you failover to the standby in case of a crash, you may accept to set full_page_writes=off and this is what I did here.</p>
<p><pre>
insert into demo     select generate_series a,generate_series b,generate_series c,generate_series d,generate_series e,generate_series f,lpad('x',100,'x') g from generate_series(1,1000000);
...
 ( written 125255680 bytes to pg_wal/000000010000000A000000E3 -&gt; total WAL segments: 140.65 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
INSERT 0 1000000
</pre>
The insert still have to log all new data: 140 MB.</p>
<p><pre>
update demo set b=b+1;
...
 ( written 72613888 bytes to pg_wal/000000010000000A000000F2 -&gt; total WAL segments: 213.02 MB ) cmd=postgres: wal writer process
UPDATE 1000001
</pre></p>
<p>The update has to log only what is modified, but because of Postgres MVCC implementation, the whole row has to be written in its new version, and the old ones have their pointer updated: 210 MB here.</p>
<p><pre>
update demo set b=b+1 where mod(a,10)=1;
 ( written 305709056 bytes to pg_wal/000000010000000A000000F3 -&gt; total WAL segments: 1.96 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
 ( written 72613888 bytes to pg_wal/000000010000000A000000F3 -&gt; total WAL segments: 5.62 MB ) cmd=postgres: wal writer process
 ( written 75718656 bytes to pg_wal/000000010000000A000000F4 -&gt; total WAL segments: 9.65 MB ) cmd=postgres: wal writer process
 ( written 310665216 bytes to pg_wal/000000010000000A000000F4 -&gt; total WAL segments: 9.65 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
UPDATE 100000
</pre></p>
<p>The sparse update benefits from logging only the changed rows: 10 MB here. This one is even smaller than with Oracle because there&#8217;s no UNDO to write here: the old values stay in-place.</p>
<p><pre>
delete from demo;
 ( written 323256320 bytes to pg_wal/000000010000000A000000F5 -&gt; total WAL segments: 11.27 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
 ( written 338829312 bytes to pg_wal/000000010000000A000000F6 -&gt; total WAL segments: 26.92 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
 ( written 76562432 bytes to pg_wal/000000010000000A000000F6 -&gt; total WAL segments: 31.41 MB ) cmd=postgres: wal writer process
 ( written 345415680 bytes to pg_wal/000000010000000A000000F7 -&gt; total WAL segments: 39.73 MB ) cmd=postgres: demo demo 192.168.56.122(38109)
 ( written 83410944 bytes to pg_wal/000000010000000A000000F7 -&gt; total WAL segments: 40.41 MB ) cmd=postgres: wal writer process
DELETE 1000001
</pre></p>
<p>The delete is cheap when full_page_writes=off because there&#8217;s only the visibility is changed but data remains (until committed and vacuumed). If you have a lot of rows to delete, then consider to set full_page_writes=off and be sure to have a backup to restore in case of crash.</p>
<h3>Oracle full page logging in backup mode</h3>
<p>So, Oracle by default does not need to protect from fractured blocks, because they can be detected. If the storage crashes while a block is partially written, the block is corrupt. Thanks to the checksum, this corruption will be detected during recovery (or even earlier depending on DB_BLOCK_CHECKSUM and DB_LOST_WRITE_PROTECT). The redo is not sufficient, as it contains only change vectors, but you can recover from the last backup and Oracle can do a simple block recover. This recovery can also be done from the standby database.</p>
<p>However, full page logging exists in Oracle. When running backup from a non-Oracle tool, not aware of block checksum, you need to enclose the copy or snapshot between &#8216;begin backup&#8217; and &#8216;end backup&#8217;. You do this because online backup may read partially updated blocks, and without the checksum, cannot detect it. A corrupt backup is not very useful and this is why this backup mode will generate more redo to be able to recover them. This is very similar to full page logging: the redo generated for the first modification of the buffer will store the whole block. Next modifications, until buffer is checkpointed, will need only the change vectors.</p>
<p>I think the first article I&#8217;ve ever written was a description of the Oracle backup mode. And it is still visible thanks to <a href="https://web.archive.org/web/20090420173840/knol.google.com/k/franck-pachot/oracle-begin-backupend-backup/17uabcrki6uux/3" target="_blank">archive.org</a> only because it was published on&#8230; Google Knol!</p>
<p>So, here is the same run with Oracle in backup mode.</p>
<p>Insert does not change a lot as it fills full blocks:
<pre>
SQL&gt; insert into demo     select rownum a,rownum b,rownum c,rownum d,rownum e,rownum f,lpad('x',100,'x') g from xmltable('1 to 1000000');
1000000 rows created.

SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
         141,376      156,527,072               4,380,448          124,195
</pre></p>
<p>Full update of one column generates same undo, but more than 2x redo because of full page logging:
<pre>
SQL&gt; update demo set b=b+1;
1000001 rows updated.

SQL&gt; commit;
Commit complete.

SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
         170,778      238,317,632              48,641,772          104,640
</pre></p>
<p>Sparse update is exactly the same as full update because this 10% touches all pages:
<pre>
SQL&gt; update demo set b=b+1 where mod(a,10)=1;
100001 rows updated.

SQL&gt; commit;
Commit complete.

SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
         319,622      240,502,284              17,832,196          192,815
</pre></p>
<p>Delete generates even more because there&#8217;s all the the UNDO in addition to all data pages:
<pre>
SQL&gt; delete from demo;
1000001 rows deleted.

SQL&gt; commit;
Commit complete.

SQL&gt; @ _mystat_diff.sql

db block changes        redo size undo change vector size     redo entries
---------------- ---------------- ----------------------- ----------------
       2,125,285      558,510,928             240,303,768        1,143,131
</pre></p>
<h3>So what?</h3>
<p>Beyond the very different implementation of Postgres and Oracle, we can see that we have flexibility: the large logging generated by Postgres by default may be reduced in some cases, and the minimal logging which is the default for Oracle may be larger in some situations. The most important, as for all technologies, is to understand how it works. Only then you can do the right choice to balance between performance, availability, and cost. Understand how it works means: read the docs (how it is supposed to work) and test (how it actually works). With Oracle there&#8217;s additional information from a huge community testing and using it for decades. With Postgres, as with all Open Source projects, the source code with comments is an amazing documentation.</p>
<table class="rw-rating-table rw-ltr rw-left rw-no-labels"><tr><td><nobr>&nbsp;</nobr></td><td><div class="rw-left"><div class="rw-ui-container rw-class-blog-post rw-urid-210840"></div></div></td></tr></table>							
		</div><!--/content-inner-->
<div class="comment-wrap ">

	<h3 id="comments"> 4 Comments</h3>

	<div class="navigation">
		<div class="alignleft"></div>
		<div class="alignright"></div>
	</div>

	<ul class="comment-list ">
				<li class="comment even thread-even depth-1" id="comment-10555">
				<div id="div-comment-10555" class="comment-body">
				<div class="comment-author vcard">
			<img alt='' src='https://secure.gravatar.com/avatar/0c0057c229b4f3490a4995e029298d65?s=60&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D60&amp;r=G' class='avatar avatar-60 photo' height='60' width='60' />			<cite class="fn">Johnnyq72</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="index.html#comment-10555">
			February 14, 2018 at 22 h 31 min</a>		</div>

		<p>Thanks for this Franck.
Hugely insightful.
You might be interested to look at the zHeap project by EDB in this space too.
<table class="rw-rating-table rw-ltr rw-left rw-no-labels">
<tr>
<td><nobr>&nbsp;</nobr></td>
<td>
<div class="rw-left">
<div class="rw-ui-container rw-class-comment rw-urid-105561"></div>
</div>
</td>
</tr>
</table>

		<div class="reply"><a class='comment-reply-link' href='index.html#comment-10555' onclick='return addComment.moveForm( "div-comment-10555", "10555", "respond", "21083" )' aria-label='Reply to Johnnyq72 to Johnnyq72'>Reply to Johnnyq72</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1 parent" id="comment-10693">
				<div id="div-comment-10693" class="comment-body">
				<div class="comment-author vcard">
			<img alt='' src='https://secure.gravatar.com/avatar/bce05003d95ea960d4b217dd8da3d048?s=60&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D60&amp;r=G' class='avatar avatar-60 photo' height='60' width='60' />			<cite class="fn"><a href='http://www.ardentperf.com' rel='external nofollow' class='url'>Jeremy Schneider</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="index.html#comment-10693">
			February 27, 2018 at 20 h 11 min</a>		</div>

		<p>Great write-up, Franck!  Regarding checksums, &#8220;another possibility is to implement a checksum on the blocks so that fractured blocks can be detected.&#8221;  Are you thinking of something beyond the checksums already available in PostgreSQL?</p>
<p><a href="https://www.postgresql.org/docs/current/static/app-initdb.html" rel="nofollow">https://www.postgresql.org/docs/current/static/app-initdb.html</a>
<table class="rw-rating-table rw-ltr rw-left rw-no-labels">
<tr>
<td><nobr>&nbsp;</nobr></td>
<td>
<div class="rw-left">
<div class="rw-ui-container rw-class-comment rw-urid-106941"></div>
</div>
</td>
</tr>
</table>

		<div class="reply"><a class='comment-reply-link' href='index.html#comment-10693' onclick='return addComment.moveForm( "div-comment-10693", "10693", "respond", "21083" )' aria-label='Reply to Jeremy to Jeremy Schneider'>Reply to Jeremy</a></div>
				</div>
		<ul class="children">
		<li class="comment even depth-2 parent" id="comment-10694">
				<div id="div-comment-10694" class="comment-body">
				<div class="comment-author vcard">
			<img alt='' src='https://secure.gravatar.com/avatar/bce05003d95ea960d4b217dd8da3d048?s=60&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D60&amp;r=G' class='avatar avatar-60 photo' height='60' width='60' />			<cite class="fn"><a href='http://www.ardentperf.com' rel='external nofollow' class='url'>Jeremy Schneider</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="index.html#comment-10694">
			February 27, 2018 at 21 h 33 min</a>		</div>

		<p>Ah &#8211; looked at the wiki and I think I see what you&#8217;re referring to.  It does seem that it&#8217;s been awhile since that part of the wiki was updated.  Do you know if anyone has been looking at this recently?
<table class="rw-rating-table rw-ltr rw-left rw-no-labels">
<tr>
<td><nobr>&nbsp;</nobr></td>
<td>
<div class="rw-left">
<div class="rw-ui-container rw-class-comment rw-urid-106951"></div>
</div>
</td>
</tr>
</table>

		<div class="reply"><a class='comment-reply-link' href='index.html#comment-10694' onclick='return addComment.moveForm( "div-comment-10694", "10694", "respond", "21083" )' aria-label='Reply to Jeremy to Jeremy Schneider'>Reply to Jeremy</a></div>
				</div>
		<ul class="children">
		<li class="comment byuser comment-author-franck-pachot bypostauthor odd alt depth-3" id="comment-10695">
				<div id="div-comment-10695" class="comment-body">
				<div class="comment-author vcard">
			<img alt='' src='https://secure.gravatar.com/avatar/9c04a89267afa42e63eeb3d620f4b873?s=60&amp;d=https%3A%2F%2Fsecure.gravatar.com%2Favatar%2Fad516503a11cd5ca435acc9bb6523536%3Fs%3D60&amp;r=G' class='avatar avatar-60 photo' height='60' width='60' />			<cite class="fn"><a href='https://www.linkedin.com/in/franckpachot' rel='external nofollow' class='url'>Franck Pachot</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="index.html#comment-10695">
			February 27, 2018 at 21 h 41 min</a>		</div>

		<p>Hi Jeremy,
Yes, I was also looking at the todo wiki right now.It links to old discussions. Seems that checksum is there. There are discussions about double writes. I don&#8217;t know if there are recent contributions on that but it seems that it will be possible to reduce the size of WAL.
<table class="rw-rating-table rw-ltr rw-left rw-no-labels">
<tr>
<td><nobr>&nbsp;</nobr></td>
<td>
<div class="rw-left">
<div class="rw-ui-container rw-class-comment rw-urid-106961"></div>
</div>
</td>
</tr>
</table>

		<div class="reply"><a class='comment-reply-link' href='index.html#comment-10695' onclick='return addComment.moveForm( "div-comment-10695", "10695", "respond", "21083" )' aria-label='Reply to Franck to Franck Pachot'>Reply to Franck</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
	</ul>

 

								<div id="respond" class="comment-respond">

<p class=aboutme>
<br/>
<table width=100%>
<tr>
<td>
<div class=message>Follow:
<a href=https://linkedin.com/in/franckpachot>Linkedin</a>, <a href=https://twitter.com/franckpachot>Twitter</a>, <a href=https://www.youtube.com/@franckpachot/community>Youtube</a>, <a href=https://mastodon.social/@FranckPachot>Mastodon</a>, <a href=https://dev.to/franckpachot>dev.to</a>
 </div>
</td><td>
<img src=https://pbs.twimg.com/profile_images/1487359683119788033/4ejaJ4S5_400x400.jpg height=100 width=100/>
</td>
</tr>
</table>
<br/>
</p>


</body></html>
